var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [TestingUtilities]\nOrder   = [:macro, :function] ","category":"page"},{"location":"api/#TestingUtilities.@Test-Tuple","page":"API","title":"TestingUtilities.@Test","text":"@Test [io=stderr] [set_failed_values=nothing] test_expr\n\nEvaluates test_expr in the context of the Test module (i.e., runs the equivalent to @test $test_expr).\n\nIf test_expr does not pass, either due to an exception or the test itself runs but does not return the expected value, an error message is printed to io with the values of the top-level expressions and any bare symbols extracted from test_expr\n\nWhen executed from an interactive Julia session and \n\n_GLOBAL_DEFINE_VARS_IN_FAILED_TESTS[] == true and set_failed_values != false\n\nor\n\nset_failed_values == true \n\nthe names + values of the bare symbols in test_expr are set in the Main module to simplify debugging the failing test case. \n\n\n\n\n\n","category":"macro"},{"location":"api/#TestingUtilities.@test_cases-Tuple","page":"API","title":"TestingUtilities.@test_cases","text":"@test_cases [io=stderr] begin \n    [test cases] \n\n    [test expressions]\nend\n\nCreate a set of test data and, for each test data point, evaluates one or more test expressions on them. The values in each test case that cause a failing test will be written to io. \n\n[test cases] must be a series of expressions of the form\n\n    variable1 | variable2 | ... | variablen \n    value11   | value12   | ... | value 1n\n    value21   | value22   | ... | value 2n\n    ...\n    valuem1   | valuem2   | ... | value mn\n\nEquivalent forms of value1 | value2 | ... | valuen are the expressions\n\n(variable1=value1, variable2=value2, ..., variablen=valuen)\n\nor \n\nvariable1 => value1, variable2 => value2, ..., variablen => valuen\n\n[test expressions] must be a series of one or more test evaluation expressions \n\n    @test cond1\n    @test cond2 \n    ...\n\nHere, each test condition expression condi evalutes to a Bool and contains zero or more values from variable1, variable2, ..., variablen.\n\nThe variable-value matrix is translated into a for-loop and each test condition is evaluated at every iteration of the loop. \n\nIf any of the tests fail or throw an exception, the set of all points that caused a test condition not to pass are printed to io, along with the corresponding test condition.\n\n\n\n\n\n","category":"macro"},{"location":"api/#TestingUtilities.define_vars_in_failed_tests-Tuple{Bool}","page":"API","title":"TestingUtilities.define_vars_in_failed_tests","text":"define_vars_in_failed_tests(value::Bool)\n\nIf value is true, variables that cause a @Test expression to fail will be  defined in Main when Julia is run in interactive mode\n\n\n\n\n\n","category":"method"},{"location":"api/#TestingUtilities.fetch_kwarg_expr-Tuple{AbstractDict{Symbol, Any}}","page":"API","title":"TestingUtilities.fetch_kwarg_expr","text":"fetch_kwarg_expr(args; expected_types, [key, arg_position, default_value])\n\nReturns the `value` corresponding to `key` derived from `kwargs` and ensure it is of type `expected_types`.\n\nAt least one of `key` and `arg_position` must be provided and `arg_position` takes precedence.\n\nSee also [@parse_kwarg_expr]\n\nArguments\n\nargs::ArgsKwargs - Parsed keyword argument expressions\n\nKeyword Arguments\n\nexpected_type::Union{Vector{<:Type}, Type} - Allowable types for value \nkey::Union{Symbol, Nothing} - Key to fetch \narg_position::Union{Int,Nothing} - Position argument to fetch\ndefault_value=nothing - Optional default value for key. Will throw an ErrorException if key is not psent in kwargs and this value is nothing. \n\n\n\n\n\n","category":"method"},{"location":"api/#TestingUtilities.parse_kwarg_expr-Tuple","page":"API","title":"TestingUtilities.parse_kwarg_expr","text":"parse_kwarg_expr(exs...) -> Dict{Symbol, Any}\n\nParse keyword arguments from a series of expressions, either of the form key=value or key\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TestingUtilities","category":"page"},{"location":"#TestingUtilities","page":"Home","title":"TestingUtilities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The TestingUtilities provides macros that helps improve the seamlessness and productivity of writing tests for your packages. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
